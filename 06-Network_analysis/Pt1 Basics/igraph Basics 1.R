### iGraph Basics / Prof. Quandt

library(igraph)

#--------------------------
# 1. Generating graphs
#--------------------------

g <- make_empty_graph()
g <-add_vertices(g, 6)
g <-add_vertices(g, 3, color = "red") 

g <-add_edges(g,c(1,3, 2,3))
g <-add_edges(g,c(1,3, 4,5, 4,8, 17, 11, 13, 15))

plot(g)
plot(g, vertex.size=40)
plot(g, vertex.size=20, edge.width=2, vertex.label.cex=0.7, edge.arrow.size = 1)

## Environment represenation - the igraph graph is  a list of 10 objects. 
## Objects 1 to 8 represent the  graph structure, object 9 is the attribute table, 
## and object 10 is used to store internal info about the graph.

## There are some useful ways to access the graph's relevant info in the console. 
## We will come back to this later again...

g
## The description of an igraph object starts with an identifier and up to four letters:
## D or U, for a directed or undirected graph
## N for a named graph (where nodes have a name attribute)
## W for a weighted graph (where edges have a weight attribute)
## B for a bipartite (two-mode) graph (where nodes have a type attribute)
## The two numbers that follow  refer to the number of nodes and edges in the graph. The description may also list node & edge attributes, for example:
## (g/c) - graph-level character attribute
## (v/c) - vertex-level character attribute
## (e/n) - edge-level numeric attribute

ecount(g)
vcount(g)
get.edgelist(g)
get.adjacency(g)
g[]
g[1,]


## Some more ways to generate graphs...
g <-graph_from_literal(A--B, B--C, C--D, D--A)
g <-graph_from_literal(a--+b, b+--c)
g <- graph_from_literal(a:b:c)
g <- graph_from_literal(h-e:f:i, j)
g <- graph_from_literal(a:b:c-c:d:e)
g <-graph_from_literal(a-b-c-d-e-f, a-g-h-b, h-e:f:i, j)

## These are labeled already, so you can print the vertex (node) names..
print(V(g)$name)

## These are standard graphs from a book, implemented in R. Try changing the number.
g <-graph_from_atlas(800)

## EXERCISE: Plot these and see what they are doing...
g<-graph.empty(n=10, directed=TRUE)
g<-graph.full(n=10, directed = FALSE, loops = FALSE)
g<-graph.star(n=10, mode="out")
g<-graph.star(n=20, mode="in")
g<-graph.ring(n=10)
g<-graph.tree(127,5)

plot(g)

g<-graph.tree(20, 3)
plot(g, layout = layout.reingold.tilford(g, root=1))
plot(g, layout=layout_with_sugiyama)

g<-graph.full(n=10, directed = FALSE, loops = FALSE)
plot(g, edge.arrow.size=.3, vertex.color="gold", vertex.size=3, vertex.frame.color="gray", vertex.label.color="black", vertex.label.cex=0.6, vertex.label.dist=0.5, edge.curved=0.8) 


## Data from an edge list - vector is interpreted as pairs by igraph, and here, vertices are generated by edges.
edges <- c(1,2, 3,2, 2,4) 
g<-graph(edges, n=max(edges), directed=TRUE)
plot(g)

g<-graph(edges=c(1,2, 2,3, 3, 1), n=10 )


## Labeled vertices ("named" network)

g<-graph(c("Vossen", "Trautmann", "Trautmann", "Wiesel", "Wiesel", 	"Vossen"),
         isolates=c("Quandt","Dozent X") )
plot(g)

g_name<-graph(c("Vossen", "Trautmann", "Trautmann", "Wiesel", "Wiesel", 	"Quandt", "Quandt", "Vossen"),
              isolates=c("Person Y","Person X") )
plot(g_name, main="Fancy Graph", edge.arrow.size=.5, vertex.color="gold", vertex.size=15, 
     vertex.frame.color="gray", vertex.label.color="black", 
     vertex.label.cex=0.8, vertex.label.dist=2, edge.curved=0.2)



## EXERCISE, extended: Some nice ones just for fun... 
## You may play with the edge/vertex attributes.

tr <- make_tree(40, children = 3, mode = "undirected")
plot(tr, vertex.size=10, vertex.label=NA) 

rn <- make_ring(40)
plot(rn, vertex.size=10, vertex.label=NA) #Keep that one for later!

er <- sample_gnm(n=100, m=40) #Erdos-Renyi random graph
plot(er, vertex.size=6, vertex.label=NA)

sw <- sample_smallworld(dim=2, size=10, nei=1, p=0.1) #Watz-Strogatz small-world model
plot(sw)
plot(sw, vertex.size=6, vertex.label=NA, layout=layout_in_circle)

ba <-  sample_pa(n=100, power=1, m=1,  directed=F) #Barabasi-Albert preferential attachment / Scale-free graphs
plot(ba, vertex.size=6, vertex.label=NA) 

zach <- graph("Zachary") # the Zachary carate club data - we will talk about this...!
plot(zach, vertex.size=10, vertex.label=NA)

rn.rewired <- rewire(rn, each_edge(prob=0.1)) #This rewires our ring from above with a probability function (for the edge endpoints).
plot(rn.rewired, vertex.size=10, vertex.label=NA)

## In case you want to get rid of some stuff (and not delete everything)
rm(ba, er, sw, edges)


#--------------------------------------------------------------------------------------
# 2. Network properties: Edges ("arrows", "links"), Vertices (nodes"), attributes
#--------------------------------------------------------------------------------------

g<-graph(c("Vossen", "Trautmann", "Trautmann", "Wiesel", "Wiesel", 	"Vossen", "Vossen", "Quandt", "Quandt", "Trautmann", "Quandt", 	"Quandt", "Vossen", "Trautmann" ),
         isolates=c("Person X", "Person Y") )
plot(g)

V(g)
E(g)

g[]
g[1,]

V(g)$name 
V(g)$gender <- c("male", "female", "male", "male", "male", "female")
E(g)$type <- "Data Science"
E(g)$weight <- 10

vertex_attr(g)
edge_attr(g)


## Optimizing the output

g <- simplify(g, remove.multiple = T, remove.loops = F )
plot(g, edge.arrow.size=.3, vertex.label.color="black", vertex.label.dist=1.5, 	vertex.color=c("pink","skyblue")[1+(V(g)$gender=="male")] ) 

## Selection of specific elements or subgroups
g2 <- induced.subgraph(g, which(V(g)$gender=="male"))
plot(g2)

degree(g)
degree(g, mode="in")
degree(g, mode="out")
plot(g, vertex.label = ifelse(degree(g) > 2, V(g)$name, NA))


#Let's go back to the lecture first and learn about matrices

#--------------------------------------
# 3. Getting network data into igraph
#--------------------------------------


## You somehow got an adjacency matrix (-> file could also be loaded into igraph)
data_matrix <- matrix(c(0,1,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1,0,1,1,0,0,0,0,1,0,0,1,0,0,0,1,0,1,1,0,1,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0), 
                      8, 
                      8, 
                      byrow = T)
g <- graph_from_adjacency_matrix(data_matrix)
plot (g)
plot(g, vertex.size=6, vertex.label=NA)

## Two files with data for vertices & edges

vertices=read.csv("/Users/thorstenquandt/Desktop/Network data/vertices_100.csv", header=T, as.is=T)
edges=read.csv("/Users/thorstenquandt/Desktop/Network data/edges_100.csv", header=T, as.is=T)

head(vertices)
head(edges)
nrow(vertices); length(unique(vertices$id))
nrow(edges); nrow(unique(edges[,c("source", "target")]))
View(edges)
View(vertices)

# Now let's combine the two into a graph.
# With graph_from_data_frame... 
# "d" expects source and target ids in the two firs rows 
# "vertices" expexts an ID in the first row. All other columns are attributes. 
net <- graph_from_data_frame(d=edges, vertices=vertices, directed=T) 
net
print.igraph(net, max.lines=50)
igraph_options(print.full = TRUE)
net[]
plot(net)

plot(net, vertex.size=5, vertex.label=NA, edge.color=adjustcolor("black", alpha.f=0.2), edge.arrow.size=0.5) 

## Some visualization options - remember: all the same data, different layouts! Feel free to experiment...
edge_weights <- E(net)$weight
vertex_sizes <- degree(net) * 0.5 + 5
l <- layout_with_fr(net, weights=edge_weights)  # Using the Fruchterman-Reingold layout, with weights
l <- layout_with_kk(net, weights=edge_weights)  # Using the Kamada-Kawai layout, with weights
l <- layout_with_dh(net)  # Using the Davidson-Harel layout
l <- layout_with_lgl(net) # Using the large graph layout
plot(net, layout=l, vertex.size=vertex_sizes, vertex.label=NA, edge.arrow.size=0.5) 

## We can also use some fancy community detection to visualize (will come back to this). 
communities <- cluster_walktrap(net)
plot(net, vertex.color=communities$membership, vertex.size=5, vertex.label=NA, edge.arrow.size=0.5)

## This one reduces the directed into an undirected network, does a community detection, then plots it.
net_undirected <- as.undirected(net, mode="collapse")
communities <- cluster_fast_greedy(net_undirected)
plot(net_undirected, vertex.color=communities$membership, vertex.size=5, vertex.label=NA)


## Adjacency matrices can also be read. Transformation is slightly different, but also simple. 
dat=read.csv(file.choose(),header=TRUE,row.names=1,check.names=FALSE)  
m=as.matrix(dat) # interprets the data frame as a matrix
print(m)
g=graph.adjacency(m,mode="undirected",weighted=NULL) 
plot(g)
plot(g, vertex.size=5, vertex.label=NA, edge.color=adjustcolor("black", alpha.f=0.2), edge.arrow.size=0.5) 

rm(g, dat, m) # Again, to get rid of it without the broom.


## EXERCISE, extended: Let's read a fancy, bigger graph. Marvel Heroes, from Kaggle. 
## The edge list contains data of two types... 

data <- read.csv("/Users/thorstenquandt/Desktop/Network data/Marvel Heroes/edges.csv", stringsAsFactors = FALSE)
g <- graph_from_data_frame(data, directed = FALSE) ## Note that this is a bipartite network so far.
V(g)$type <- bipartite_mapping(g)$type ## This maps the vertices to two groups (with a TRUE/FALSE statement
V(g)$color <- ifelse(V(g)$type, "blue", "red")
plot(g, vertex.color = V(g)$color, layout = layout_as_bipartite(g)) ## Many heroes, and a lot of comics...

## Now let's generate a one-mode network of heroes...
hero_proj <- bipartite_projection(g) ## This "projects" to two networks. Basically splitting into two networks according to groups.
hero_net <- hero_proj$proj1 ## This defines the one group as the hero list. 
comic_net <- hero_proj$proj2
adj_matrix <- as_adjacency_matrix(hero_net)
print(adj_matrix)

degree_values <- degree(hero_net) ## Some voodoo for the labeling.
normalized_degree <- 0.5 + (degree_values - min(degree_values)) / max(degree_values - min(degree_values)) * 1.2  ## Some vodoo for the labeling.
layout <- layout_with_kk(hero_net)
par(mfrow=c(1,1), mar=c(0.1,0.1,0.1,0.1), pin=c(5,5))
plot(hero_net, vertex.label.cex = normalized_degree)
plot(hero_net, vertex.size=normalized_degree, layout=layout, vertex.label.cex = normalized_degree, edge.color=adjustcolor("black", alpha.f=0.2), edge.arrow.size=0.5) 

## Graphics are still horrible. Why?
summary(degree_values)

## Partial networks if the plot is too ugly/not useful. Play with the parameters. Both check long tail and core group.
nodes_to_remove <- which(degree(hero_net) < 500)
hero_filtered <- delete.vertices(hero_net, nodes_to_remove)
degree_filtered <- degree(hero_filtered)
mean(degree_filtered)
max(degree_filtered)
min(degree_filtered)
layout <- layout_with_kk(hero_filtered)
plot(hero_filtered)
plot(hero_filtered, vertex.size=3, layout=layout, vertex.label=NA, edge.color=adjustcolor("black", alpha.f=0.2), edge.arrow.size=0.5) 
plot(hero_filtered, vertex.size=3, layout=layout, vertex.label.cex = 1, edge.color=adjustcolor("black", alpha.f=0.2), edge.arrow.size=0.5) 

#vertex_data <- as.data.frame(get.vertex.attribute(hero_net))
#write.csv(vertex_data, file="/Users/thorstenquandt/Desktop/Network data/hero_net_nodes.csv", row.names=FALSE)
#edge_data <- get.data.frame(hero_net, what="edges")
#write.csv(edge_data, file="/Users/thorstenquandt/Desktop/Network data/hero_net_edges.csv", row.names=FALSE)
